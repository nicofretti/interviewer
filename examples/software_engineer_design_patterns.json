[
    {
        "role": "Interviewer",
        "message": "Explain the Singleton design pattern and how you would implement it in your code. Discuss the pros and cons of using this pattern."
    },
    {
        "role": "Candidate",
        "message": "The Singleton pattern ensures a class has only one instance and provides a global point of access to it. \n\nTo implement it, I would:\n1. Make the constructor private to prevent direct instantiation. \n2. Provide a static method or property that returns the sole instance, lazily creating it if needed.\n3. Ensure the class is thread-safe for multithreaded use.\n\nIn C#, it would look like:\n\npublic sealed class Singleton\n{\n    private static readonly Lazy<Singleton> lazy = new Lazy<Singleton>(() => new Singleton());\n    \n    public static Singleton Instance { get { return lazy.Value; } }\n\n    private Singleton() { }\n}\n\nPros:\n- Ensures only one instance exists, avoiding duplicate objects\n- Provides a global access point\n- Lazy initialization avoids unnecessary resource use\n\nCons: \n- Tightly couples code to the singleton, reducing testability\n- Harder to subclass if needed\n- Can mask bad design like too many responsibilities in one class\n\nSo I use it sparingly for things like configuration, logging, or device access where it makes sense to have a single, globally accessible instance. But I avoid it for business logic classes."
    },
    {
        "role": "Interviewer",
        "message": "Describe the differences between inheritance and composition, and provide an example of when you would choose one over the other."
    },
    {
        "role": "Candidate",
        "message": "Inheritance is an \"is-a\" relationship where a subclass inherits properties and methods from a superclass. It's useful for sharing common functionality among related classes. For example, if you have a Vehicle superclass, you could have Car and Motorcycle subclasses that inherit the drive() method.\n\nComposition is a \"has-a\" relationship where a class contains instances of other classes as members. It allows combining simpler classes into more complex ones. Composition is more flexible than inheritance. \n\nI would choose composition over inheritance when the relationship is not clearly hierarchical. For example, rather than having a Car class inherit from Engine, Wheels and Doors classes, it's cleaner to compose a Car from engine, wheels and doors objects. This avoids deep, restrictive hierarchies. Composition also allows changing the component objects at runtime.\n\nIn summary, I use inheritance for true specialization with shared functionality, and composition for assembling or containing objects to create new functionality. The \"is-a vs has-a\" guideline helps me decide which is appropriate for the situation."
    },
    {
        "role": "Interviewer",
        "message": "What is the purpose of the Factory Method design pattern, and how does it differ from the Abstract Factory pattern? Provide an example use case for each."
    },
    {
        "role": "Candidate",
        "message": "The Factory Method pattern defines an interface for creating objects, but lets subclasses decide which class to instantiate. It lets a class defer instantiation to subclasses. For example, a document editor could define a factory method for creating shapes, allowing subclasses to provide their own shape implementations like circles or rectangles.\n\nIn contrast, the Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. It's useful when a system needs to be independent of how its objects are created and composed. An example is a UI toolkit with abstract factories for different look-and-feels, each providing a family of UI component objects with a consistent style.\n\nThe key difference is that Factory Method creates single objects through inheritance, while Abstract Factory creates families of objects through object composition. Factory Method uses subclasses to vary the instantiated product, while Abstract Factory delegates responsibility to another object via composition."
    },
    {
        "role": "Interviewer",
        "message": "Explain the concept of SOLID principles in object-oriented design. Discuss how you would apply the Single Responsibility Principle to a software system you have worked on."
    },
    {
        "role": "Candidate",
        "message": "SOLID is an acronym representing five key design principles for writing maintainable and extensible object-oriented code:\n\nSingle Responsibility Principle (SRP): A class should have only one reason to change, meaning it should have a single, well-defined responsibility. \n\nOpen-Closed Principle (OCP): Classes should be open for extension but closed for modification. New functionality can be added by creating new classes that inherit or compose existing ones.\n\nLiskov Substitution Principle (LSP): Subtypes must be substitutable for their base types without altering program correctness. Derived classes must not change the behavior of the base class.\n\nInterface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they don't use. Interfaces should be fine-grained and client-specific.\n\nDependency Inversion Principle (DIP): High-level modules should depend on abstractions, not concrete implementations. Depend on interfaces, not classes.\n\nIn a recent project, I applied SRP by refactoring a large Employee class that handled payroll calculation, database persistence, and reporting. I split it into separate classes each handling a single concern:\n\n- EmployeeEntity for persistence \n- PayrollCalculator for payroll logic\n- EmployeeReportGenerator for reporting\n\nThis made the code more cohesive, easier to understand and maintain. Changes to one area, like adding a new payroll rule, could be made without modifying unrelated parts."
    },
    {
        "role": "Interviewer",
        "message": "What is the Decorator design pattern, and how would you use it to add additional responsibilities to an object at runtime? Provide an example implementation."
    },
    {
        "role": "Candidate",
        "message": "The Decorator pattern is a structural design pattern that allows you to dynamically attach additional responsibilities or behaviors to an object without modifying its structure. It involves creating decorator classes that wrap the original object and provide additional or modified functionality.\n\nHere's an example implementation in Python:\n\n```python\nclass Component:\n    def operation(self):\n        pass\n\nclass ConcreteComponent(Component):\n    def operation(self):\n        return \"ConcreteComponent\"\n\nclass Decorator(Component):\n    def __init__(self, component):\n        self._component = component\n\n    def operation(self):\n        return self._component.operation()\n\nclass ConcreteDecoratorA(Decorator):\n    def operation(self):\n        return f\"ConcreteDecoratorA({self._component.operation()})\"\n\nclass ConcreteDecoratorB(Decorator):\n    def operation(self):\n        return f\"ConcreteDecoratorB({self._component.operation()})\"\n\ndef client_code(component):\n    print(f\"RESULT: {component.operation()}\")\n\nif __name__ == \"__main__\":\n    simple = ConcreteComponent()\n    client_code(simple)\n\n    decorator1 = ConcreteDecoratorA(simple)\n    decorator2 = ConcreteDecoratorB(decorator1)\n    client_code(decorator2)\n```\n\nIn this example:\n- `Component` defines the interface for objects that can have responsibilities added to them dynamically.\n- `ConcreteComponent` is the original object to which additional responsibilities can be attached.\n- `Decorator` maintains a reference to a `Component` object and defines an interface that conforms to `Component`'s interface.\n- `ConcreteDecoratorA` and `ConcreteDecoratorB` are concrete decorators that add responsibilities to the component.\n\nAt runtime, you can wrap the `ConcreteComponent` with one or more decorators to add new behavior:\n\n```python\nsimple = ConcreteComponent()\ndecorator1 = ConcreteDecoratorA(simple)\ndecorator2 = ConcreteDecoratorB(decorator1)\n```\n\nThe resulting object `decorator2` will have the additional responsibilities provided by both `ConcreteDecoratorA`"
    },
    {
        "role": "Interviewer",
        "message": "Describe the Adapter design pattern and explain how it can be used to integrate two incompatible interfaces. Provide an example scenario where you would use this pattern."
    },
    {
        "role": "Candidate",
        "message": "The Adapter pattern allows classes with incompatible interfaces to work together by wrapping one interface with another.\n\nIt involves creating an Adapter class that implements the interface the client expects, while internally delegating to an Adaptee object that has the functionality the client needs but an incompatible interface.\n\nFor example, say we have a legacy BillingSystem that only works with XML data, but our client code uses a modern Invoice object. We could create an XMLInvoiceAdapter that implements the same interface as Invoice, but internally converts the data to XML and passes it to the legacy BillingSystem.\n\nClient code -> Invoice interface <- XMLInvoiceAdapter -> XML data -> BillingSystem\n\nThis allows the client to keep using the Invoice abstraction it expects, while still integrating with the legacy system. The adapter translates between the two incompatible interfaces.\n\nI've used this pattern to integrate third-party libraries that had an API different from what my application's design required. The adapter allowed me to indirectly access the library functionality through an interface that fit my application's architecture better."
    },
    {
        "role": "Interviewer",
        "message": "Explain the concept of dependency injection and how it relates to the Inversion of Control principle. Discuss the benefits of using dependency injection in your software designs."
    },
    {
        "role": "Candidate",
        "message": "Dependency injection is a design pattern where an object's dependencies are provided to it externally rather than the object creating them itself. Instead of a class instantiating its own dependencies, they are \"injected\" via the constructor, methods, or properties.\n\nThis relates to the Inversion of Control principle because the control of creating and managing dependencies is inverted. Rather than the class controlling its dependencies, that control is given to an external framework or container which injects the dependencies.\n\nThe benefits of dependency injection include:\n\n1. Loose coupling - Classes are less tightly coupled to their dependencies, making the system more modular and maintainable. Dependencies can be easily swapped out.\n\n2. Easier testing - Dependencies can be mocked or stubbed, allowing classes to be tested in isolation. This enables unit testing.\n\n3. Separation of concerns - Classes no longer need to worry about creating their dependencies, they can focus solely on using them. This leads to cleaner, more focused code.\n\n4. Reusability - Dependencies can be shared and reused across the system more easily.\n\n5. Centralized configuration - Dependencies and their lifetimes can be configured in a central location, like a DI container, providing a clear overview of the system.\n\nFor example, I've used dependency injection in a web API project. The controllers depended on various services, but instead of instantiating the services themselves, they were injected via the controller's constructor. This made the controllers more testable and allowed the services to be easily replaced or decorated without modifying the controllers."
    },
    {
        "role": "Interviewer",
        "message": "How would you implement the Observer design pattern to decouple the subject and observer objects in your code? Discuss the advantages and potential drawbacks of this pattern."
    },
    {
        "role": "Candidate",
        "message": "To implement the Observer pattern, I would:\n\n1. Define a Subject interface with methods like registerObserver(), removeObserver(), and notifyObservers(). The concrete subject class implements this interface.\n\n2. Define an Observer interface with an update() method. Concrete observers implement this to receive updates from the subject.\n\n3. When state changes, the subject calls notifyObservers() which loops through registered observers and calls their update() method.\n\n4. Observers register/unregister themselves with the subject as needed using registerObserver() and removeObserver().\n\nAdvantages:\n- Decouples subjects and observers for flexibility \n- Allows broadcasting to multiple observers\n- Supports dynamic observer registration at runtime\n\nDrawbacks: \n- Can be complex for simple scenarios\n- Unexpected updates if an observer affects the state of the subject\n- Potential performance issues with many observers\n\nOverall, the Observer pattern provides a clean way to react to state changes while keeping classes loosely coupled. It's well-suited for scenarios like GUIs, event handling, and distributed systems."
    },
    {
        "role": "Interviewer",
        "message": "Describe the Strategy design pattern and explain how it can be used to encapsulate different algorithms or behaviors. Provide an example of when you would use this pattern in your code."
    },
    {
        "role": "Candidate",
        "message": "The Strategy pattern defines a family of interchangeable algorithms, encapsulates each one, and makes them interchangeable within that family. This allows the algorithm to vary independently from clients that use it.\n\nA practical example is a payment processing system that needs to support multiple payment gateways like PayPal, Stripe, etc. Each gateway has its own algorithm for processing payments.\n\nI would define a PaymentStrategy interface declaring a processPayment method. Then create concrete strategy classes like PayPalStrategy and StripeStrategy that implement this interface and encapsulate gateway-specific processing logic.\n\nThe client code would receive a strategy object and call its processPayment method, without knowing the concrete class. This makes strategies interchangeable and extensible without modifying existing code.\n\nFor instance, an OrderService could receive a PaymentStrategy in its constructor. Its createOrder method would call strategy.processPayment(). We can pass it a PayPalStrategy or StripeStrategy, and easily add new strategies later.\n\nThis decouples the OrderService from payment details and makes the system open for extension but closed for modification, following the Open-Closed Principle."
    },
    {
        "role": "Interviewer",
        "message": "Explain the concept of polymorphism in object-oriented programming. Provide an example of how you would implement polymorphism in your code using inheritance or interfaces."
    },
    {
        "role": "Candidate",
        "message": "Polymorphism allows objects of different classes to be treated as objects of a common parent class. This enables writing more generalized, reusable code.\n\nOne way to achieve polymorphism is through inheritance. For example, consider a base class Shape with a virtual method CalculateArea(). Derived classes like Circle and Rectangle override this method to provide their own implementations:\n\n```cpp\nclass Shape {\npublic:\n    virtual double CalculateArea() = 0;\n};\n\nclass Circle : public Shape {\npublic:\n    double CalculateArea() override {\n        return 3.14 * radius * radius; \n    }\nprivate:\n    double radius;\n};\n\nclass Rectangle : public Shape {\npublic:  \n    double CalculateArea() override {\n        return length * width;\n    }\nprivate:\n    double length, width;\n};\n```\n\nNow, Shape pointers can point to Circle or Rectangle objects, and calling CalculateArea() will invoke the appropriate overridden method polymorphically:\n\n```cpp\nShape* shapes[2];\nshapes[0] = new Circle(5);\nshapes[1] = new Rectangle(4, 6);\n\nfor(int i = 0; i < 2; i++) {\n    cout << shapes[i]->CalculateArea() << endl;\n}\n```\n\nThis prints the area of the circle and rectangle by calling the specific CalculateArea() implementation for each derived class.\n\nInterfaces provide another polymorphism approach. Classes implementing an interface must define all its methods, enabling the interface to serve as a contract."
    }
]